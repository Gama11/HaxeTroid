So first thing we want to do is initial setup. Let's get acquainted with our three starter classes:

Main
PlayState
AssetPaths

Main is by default the first thing that runs in a HaxeFlixel game. If there's anything you want to run once and at the very beginning, this is where you'd put it. As is, it just creates a new game.

We want to change this line to 

```
//Make a new flixel game of resolution 256x144 that starts on PlayState
AddChild(new FlxGame(256, 144, PlayState))
```

This line essentially says: 
1. Make a new Flixel Game
2. With resolution 256x144 (which is a widescreen 16:9)
3. And start it on PlayState

PlayState is our first State, which is just what it sounds like - a state of your game. With game dev (and programming in general) you want to focus on compartimentalization - seperating a big task into several smaller tasks. The biggest of these tasks in a game is seperating them into these States. For example, we can have a Menu State, Highscore State, and of course, Play State.

For our tutorial, the majority of our work with placing things on the game to be played with (player, enemies, levels, etc.) will be done in PlayState.

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

Creating the Player

Let's create a new class that extends FlxSprite called Player

We're going to essentially add some scaffolding for a Player in the form of functions. As I've said before, the focus on this tutorial is not just development but how to organize big tasks into little-er tasks. So let's consider what we want. We want to create a little spaceperson who can shoot, walk, and fly, they'll encounter enemies and get hit by them and if they take enough damage they die. So to break that down we want our player to:

1. Walk
2. Jump/Jetpack
3. Shoot/Charge Missiles
4. Animate their movements
5. Take Damage
6. Die/Respawn

To do all this they'll need some variables. Health, MaxHealth, Missile Fire Rate, etc. And we want all this to be modifiable later through upgrades, so let's really variable it out and intialize those now at the *top* of the class:

```
	/** max speed they on the X axis (horizontal) **/
	var maxSpeed:Int = 100;
	
	/** frames to reach max speed (60 frames per second) **/
	var framesToMaxSpeed:Int = 15;
	
	/** max health (also the default health when the player respawns) **/
	var maxHealth:Int = 100;
	
	/** default is full charge after 1 second (30 frames) **/
	var chargeRate:Int = 30;
	
	/** our intial jump, negative is up **/
	var initialJump:Int = -100;
	
	/** jetpack lift acceleration **/
	var lift:Int = 15;
	
	/** max jetpack lift **/
	var liftMax:Int = 60;
	
	/** max fuel, lose 1 per frame **/
	var fuelMax:Int = 40;
	
	/** player's current fuel **/
	var fuel:Int = 0;
```

So all in all our class should look like this so far:

```

package;

import flixel.FlxSprite;
import flixel.system.FlxAssets.FlxGraphicAsset;


/**
 * A player that walks, jumps, jetpacks, and shoots!
 * @author <Your Name Here>
 */
class Player extends FlxSprite 
{
	/** max speed they on the X axis (horizontal) **/
	var maxSpeed:Int = 100;
	
	/** frames to reach max speed (60 frames per second) **/
	var framesToMaxSpeed:Int = 15;
	
	/** max health (also the default health when the player respawns) **/
	var maxHealth:Int = 100;
	
	/** default is full charge after 1 second (30 frames) **/
	var chargeRate:Int = 30;
	
	/** our intial jump, negative is up **/
	var initialJump:Int = -100;
	
	/** jetpack lift acceleration **/
	var lift:Int = 15;
	
	/** max jetpack lift **/
	var liftMax:Int = 60;
	
	/** max fuel, lose 1 per frame **/
	var fuelMax:Int = 40;
	
	/** player's current fuel **/
	var fuel:Int = 0;
	
	public function new(?X:Float=0, ?Y:Float=0, ?SimpleGraphic:FlxGraphicAsset) 
	{
		super(X, Y, SimpleGraphic);
		
		//just a simple square for now
		makeGraphic(20, 20);
		
		//set the max speed, Flixel won't let the object get any faster than this!
		maxVelocity.x = maxSpeed;
		
		//gravity, down is positive, up is negative
		acceleration.y = 200;
		
		//floor friction
		drag.x = 250;
	}

}

```

This may seem like a long class for something that... well, it doesn't do anything yet. But trust me - this will make your life a lot easier in the future!
 
So what we're going to do here is make a bunch of empty functions that'll act as a in-code "TODO" list. We'll just comment the ones we're not dealing with right now:


```
/** Main player loop **/
override public function update(elapsed:Float):Void 
{
	walk();
	/*
	TODO:
	jump();
	shoot();
	Take Damage functions
	*/
		
	super.update(elapsed);
}
```

Alright, finally time to make our little square move. First, we need to import FlxG, which is a static reference to the game. This allows you to access the primary camera, variables, and most commonly the keys! So let's add `import flixel.FlxG;` at the top of your class, and while we're at it, let's throw in FlxObject which we'll need later. Your imports should look like this:

```
package;

import flixel.FlxG;
import flixel.FlxObject;
import flixel.FlxSprite;
import flixel.system.FlxAssets.FlxGraphicAsset;
```

Now let's, yanno, actually move our square.

Normally you'd want to just set acceleration.x to whatever you want, and you can still do that, but I find it easier to actually have a constant rate of increase measured in frames. It looks a little more complicated in code but overall it's way more controllable. It'll end up looking like this:

```
/** Walk around left to right **/
function walk()
{
	if (FlxG.keys.anyPressed(["LEFT"]))
	{
		//move to the LEFT (negative)
		velocity.x -= maxSpeed / framesToMaxSpeed;
	}
	if (FlxG.keys.anyPressed(["RIGHT"]))
	{
		//move to the RIGHT (positive)
		velocity.x -= maxSpeed / framesToMaxSpeed;
	}
}
```

And that's it! Because we set the drag.x, the player will automatically slow down. Because we set maxVelocity.x, we don't have to worry about them going over the speed limit either!

Optional:

I prefer to do this in my games as it gives smoother movement, which is that you actually accelerate faster when you're trying to turn around quickly. To do that all we need to do is detect if the player is going the opposite direction of the direction they're trying to do, and then just add more velocity.

```
/** Walk around left to right **/
function walk()
{
	if (FlxG.keys.anyPressed(["LEFT"]))
	{
		//move to the LEFT (negative)
		velocity.x -= maxSpeed / framesToMaxSpeed;
		//if we're going to the RIGHT, slow down the player's speed (so they turn around faster)
		if (velocity.x > 0) velocity.x * .95;
	}
	if (FlxG.keys.anyPressed(["RIGHT"]))
	{
		//move to the RIGHT (positive)
		velocity.x += maxSpeed / framesToMaxSpeed;
		//if we're going to the LEFT, slow down the player's speed (so they turn around faster)
		if (velocity.x < 0) velocity.x * .95;
	}
}
```

Okay, let's shift gears for a moment and actually add our player to the game so we can see the result of what we've done. Go back to your PlayState and simply add the Player to the game and store them as a variable. In other words, make your PlayState look like this.

We'll also add a simple test platform and give it collision (by doing a collide check in update, which is called every frame)

```
 
package;

import flixel.FlxSprite;
import flixel.FlxState;
import flixel.FlxG;

class PlayState extends FlxState
{
	var player:Player;
	var testPlatform:FlxSprite;
	
	override public function create():Void
	{
		super.create();
		
		//add and assign the player variable in one line, nifty!
		add(player = new Player(100, 100));
		
		//make a simple test platform
		add(testPlatform = new FlxSprite(0, player.y + player.height));
		//creates a simple rectangle
		testPlatform.makeGraphic(FlxG.width, 100);
		//stops the platform from moving when the player touches it
		testPlatform.immovable = true;
	}

	override public function update(elapsed:Float):Void
	{
		//give the testPlatform Collision with the player
		FlxG.collide(player, testPlatform);
		
		super.update(elapsed);
	}
}


```

Okay so if we run the game you'll see your little square no longer falls to the abyss, yay! Now we need to make them jump. Jump code is really easy in Flixel, all we need to understand is

1. How to detect when we're on the floor
2. How to make the character jump !

So let's update our TODO in the Update() function to

override public function update(elapsed:Float):Void 
{
	walk();
	jump();
	/*
	TODO:
	shoot();
	Take Damage functions
	*/
		
	super.update(elapsed);
}

```

And make our jump function:
	
```

/** Press UP to jump! **/
function jump() {
	//1. Detect we're on the floor
	var onGround:Bool = isTouching(FlxObject.FLOOR);
	
	//2. If we're on the ground...
	if (onGround) 
	{
		//We can jump if the UP key is pressed!
		if (FlxG.keys.anyJustPressed(["UP"])){
			velocity.y = initialJump;
		}
	}
}

```

If you run it now and press up, you should be able to jump!

Admittedly, it's not that high of a jump, and that's because of this next bit, the jetpack! Basically, if we're on the floor and pressing UP we'll switch to jetpack mode, as long as we have fuel, we'll have lift. So to break it down:
	
1. If we press UP and we have fuel
2. Add lift and decrease fuel
3. When they're on the floor, add fuel back.

When the player holds up, the jetpack will carry their lift. We're also adding a max lift so that they don't go off the rails and just go infinitely higher. In addition, when they're on the floor. So add this to the end of jump()

```

//Jetpack handler
//J1. If we press UP and we have fuel
if (FlxG.keys.anyJustPressed(["UP"]) && fuel > 0) 
{
	//J2. Add lift and decrease fuel
	velocity.y -= lift;
	fuel--;
	//Max velocity so they don't go flying infinitely faster
	if (velocity.y < -liftMax) {
		velocity.y = -liftMax;
	}
}
//J3. When they're on the floor, add fuel back.
if (!onGround) 
{
	//They'll recharge in 20 frames
	fuel += Math.ceil(fuelMax / 20);
	if (fuel > fuelMax) {
		fuel = fuelMax;
	}
}

```

Hold up now. If you test your game you'll see the controls for jump and jetpack overlap, and the result is if you're holding down jump you'll immediately start wasting jetpack fuel. So to game design around this, let's change the controls a bit - when you let go of jump and press it again midair, you'll start using your jetpack! So let's make a new variable that is called "jetpackMode" which is only True if the player released the jump button. It is set back to False if they touch the ground. So overall our code should look like this:
