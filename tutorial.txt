So first thing we want to do is initial setup. Let's get acquainted with our three starter classes:

Main
PlayState
AssetPaths

Main is by default the first thing that runs in a HaxeFlixel game. If there's anything you want to run once and at the very beginning, this is where you'd put it. As is, it just creates a new game.

We want to change this line to 

```
//Make a new flixel game of resolution 256x144 that starts on PlayState
AddChild(new FlxGame(256, 144, PlayState))
```

This line essentially says: 
1. Make a new Flixel Game
2. With resolution 256x144 (which is a widescreen 16:9)
3. And start it on PlayState

PlayState is our first State, which is just what it sounds like - a state of your game. With game dev (and programming in general) you want to focus on compartimentalization - seperating a big task into several smaller tasks. The biggest of these tasks in a game is seperating them into these States. For example, we can have a Menu State, Highscore State, and of course, Play State.

For our tutorial, the majority of our work with placing things on the game to be played with (player, enemies, levels, etc.) will be done in PlayState.

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

Creating the Player

Let's create a new class that extends FlxSprite called Player

We're going to essentially add some scaffolding for a Player in the form of functions. As I've said before, the focus on this tutorial is not just development but how to organize big tasks into little-er tasks. So let's consider what we want. We want to create a little spaceperson who can shoot, walk, and fly, they'll encounter enemies and get hit by them and if they take enough damage they die. So to break that down we want our player to:

1. Walk
2. Jump/Jetpack
3. Shoot/Charge Missiles
4. Animate their movements
5. Take Damage
6. Die/Respawn

To do all this they'll need some variables. Health, MaxHealth, Missile Fire Rate, etc. And we want all this to be modifiable later through upgrades, so let's really variable it out and intialize those now at the *top* of the class:

```
	var speed:Int = 400; //acceleration on the X axis (horizontal)
	var maxSpeed:Int = 100; //max speed they on the X axis (horizontal)
	
	var maxHealth:Int = 100; //max health (also the default health when the player respawns)
	
	var chargeRate:Int = 30; //default is full charge after 1 second (30 frames)
	
	var lift:Int = 15; //jetpack lift acceleration
	var liftMax:Int = 60; //max jetpack lift
```

So what we're going to do here is make a bunch of empty functions that'll act as a in-code "ToDo" list. We'll just comment the ones we're not dealing with right now:

```
override public function update(elapsed:Float):Void 
	{
		walk();
		/*
		TODO:
		jump();
		shoot();
		Take Damage functions
		*/
		
		super.update(elapsed);
	}
```